package com.atlassian.db.replica.api;

import com.atlassian.db.replica.api.mocks.ConnectionProviderMock;
import com.atlassian.db.replica.api.mocks.PermanentConsistency;
import org.junit.Test;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import static org.mockito.Mockito.verify;

public class TestCreateStatements {
    @SuppressWarnings({"SqlDialectInspection", "SqlNoDataSourceInspection"})
    public static final String SELECT = "SELECT 1;";
    private final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();

    @Test
    public void shouldPrepareStatementWhenExecute() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();

        connection.prepareStatement(SELECT).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SELECT);
    }

    @Test
    public void shouldPrepareStatementWithAutoGeneratedKeys() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;

        connection.prepareStatement(SELECT, autoGeneratedKeys).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SELECT, autoGeneratedKeys);
    }

    @Test
    public void shouldPrepareStatementWithColumnNames() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final String[] columnNames = {"test"};

        connection.prepareStatement(SELECT, columnNames).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SELECT, columnNames);
    }

    @Test
    public void shouldPrepareStatementWithColumnIndexes() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int[] columnIndexes = {123};

        connection.prepareStatement(SELECT, columnIndexes).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SELECT, columnIndexes);
    }

    @Test
    public void shouldPrepareStatementWithResultSetHoldability() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
        final int resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;

        connection.prepareStatement(SELECT, resultSetType, resultSetConcurrency, resultSetHoldability).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(
            SELECT,
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }

    @Test
    public void shouldCreateStatement() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();

        connection.createStatement().execute(SELECT);

        verify(connectionProvider.getProvidedConnections().get(0)).createStatement();
    }

    @Test
    public void shouldCreateStatementWithResultSetType() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;


        connection.createStatement(resultSetType, resultSetConcurrency).execute(SELECT);

        verify(connectionProvider.getProvidedConnections().get(0)).createStatement(resultSetType, resultSetConcurrency);
    }

    @Test
    public void shouldCreateStatementWithResultSetHoldability() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
        final int resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;

        connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability).execute(SELECT);

        verify(connectionProvider.getProvidedConnections().get(0)).createStatement(
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }

    @Test
    public void shouldPrepareCall() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();

        connection.prepareCall(SELECT).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareCall(SELECT);
    }

    @Test
    public void shouldPrepareCallWithResultSetType() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = 1;
        final int resultSetConcurrency = 2;

        connection.prepareCall(SELECT, resultSetType, resultSetConcurrency).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareCall(
            SELECT,
            resultSetType,
            resultSetConcurrency
        );
    }

    @Test
    public void shouldPrepareCallWithResultSetHoldability() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = 1;
        final int resultSetConcurrency = 2;
        final int resultSetHoldability = 3;

        connection.prepareCall(SELECT, resultSetType, resultSetConcurrency, resultSetHoldability).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareCall(
            SELECT,
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }
}
